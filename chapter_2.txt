1) Какой самый эффективный способ конкатенации строк?
strings.Builder

2) Что такое интерфейсы, как они применяются в Go?
Интерфейс представляет своего рода контракт, которому должен соответствовать тип данных. Чтобы тип данных
соответствовал некоторому интерфейсу, данный тип должен реализовать в виде методов все функции этого интерфейса.

3) Чем отличаются RWMutex от Mutex?
Mutex (Mutual Exclusion) является простым механизмом блокировки, который позволяет только одной горутине получить доступ
к критической секции кода в определенный момент времени. Если горутина заблокировала Mutex, то остальные горутины
будут ожидать до тех пор, пока Mutex не будет освобожден.
RWMutex позволяет множеству горутин получить параллельный доступ для чтения (блокировка чтения),
но только одной горутине получить эксклюзивный доступ на запись (блокировка записи).

4) Чем отличаются буферизированные и не буферизированные каналы?
Не буферизированные каналы - это каналы, которые не имеют внутреннего буфера и требуют блокировки отправителя и
получателя при передаче данных. Это означает, что отправитель будет заблокирован до тех пор, пока получатель
не прочитает данные из канала, и наоборот - получатель будет заблокирован до тех пор, пока отправитель
не передаст данные.
Буферизированные каналы - это каналы, которые имеют внутренний буфер и позволяют отправителю передавать данные,
даже если получатель еще не готов к их приему. Буферизированные каналы в Go позволяют уменьшить количество блокировок
и увеличить производительность программы.

5) Какой размер у структуры struct{}{}?
0 байт

6) Есть ли в Go перегрузка методов или операторов?
Нет

7) В какой последовательности будут выведены элементы map[int]int?
   Пример:
   m[0]=1
   m[1]=124
   m[2]=281

В случайном

8) В чем разница make и new?
new инициализирует нулевое значение для данного типа и возвращает указатель на этот тип.
make используется исключительно для создания и инициализации срезов, отображений и каналов,
возвращает ненулевой экземпляр указанного типа.
Основное отличие между ними состоит в том, что make возвращает инициализированный тип,
готовый к использованию после создания, а new – указатель на тип с его нулевым значением.

9) Сколько существует способов задать переменную типа slice или map?
    1. s := make([]byte, 5, 5)
       m := make(map[int]int)
    2. var m map[int]int
       var s []byte
    3. m := map[int]int{}
       s3 := []byte{}

10) Что выведет данная программа и почему?
    func update(p *int) {
      b := 2
      p = &b
    }

    func main() {
      var (
         a = 1
         p = &a
      )
      fmt.Println(*p)
      update(p)
      fmt.Println(*p)
    }

    1
    1

    Потому что p передан по значению. Необходимо либо вернуть новое значение p, либо передать по указателю (p **int)

11) Что выведет данная программа и почему?
    func main() {
      wg := sync.WaitGroup{}
      for i := 0; i < 5; i++ {
         wg.Add(1)
         go func(wg sync.WaitGroup, i int) {
            fmt.Println(i)
            wg.Done()
         }(wg, i)
      }
      wg.Wait()
      fmt.Println("exit")
    }

    2
    3
    fatal error: all goroutines are asleep - deadlock!
    потому что wg надо передавать по указателю. В данном случае он был передан по значению и горутины выполняли
    wg.Done() для своих копий wg. В результате wg.Wait() застрял, т.к. никто не выполнил wg.Done для его экземпляра wg.

12) Что выведет данная программа и почему?
    func main() {
      n := 0
      if true {
         n := 1
         n++
      }
      fmt.Println(n)
    }

    0
    потому что в цикле была создана новая (локальная) переменная n

13) Что выведет данная программа и почему?
    func someAction(v []int8, b int8) {
      v[0] = 100
      v = append(v, b)
    }

    func main() {
      var a = []int8{1, 2, 3, 4, 5}
      someAction(a, 6)
      fmt.Println(a)
    }

    [100 2 3 4 5]

    1. изменение элемента слайса не влечет изменение указателя, поэтому изменения видно извне
    2. при добавлении нового элемента была превышена емкость слайса, был создан новый (копия), но с большей емкостью
    В результате v имеет новое значение, которое не было возвращено

14) Что выведет данная программа и почему?
    func main() {
      slice := []string{"a", "a"}

      func(slice []string) {
         slice = append(slice, "a")
         slice[0] = "b"
         slice[1] = "b"
         fmt.Print(slice)
      }(slice)
      fmt.Print(slice)
    }

    [b b a][a a]
    1. слайс передан по значению
    2. функция append создала новый слайс (т.к. при добавлении нового элемента была превышена емкость текущего слайса)
    3. дальнейшее изменение элементов было на новом экземпляре slice, который не был возвращен